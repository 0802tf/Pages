# 正規表現

## 基本的な正規表現

|文字|説明|
|-|-|
|.|任意の1文字|
|?|直前の文字が0個か1個|
|+|直前の文字が1個以上(最長一致)|
|*|直前の文字が0個以上(最長一致)|
|+?|直前の文字が1個以上(最短一致)|
|*?|直前の文字が0個以上(最短一致)|
|A\|B|AまたはBのいずれか(OR条件)|
|¥|直後の正規表現記号をエスケープ|
|[...]|角括弧に含まれるいずれか1文字|
|[^...]|角括弧に含まれる文字以外|
|(...)|文字を1つのグループにまとめる|
|{n}|直前の文字がn個|
|{n,}|直前の文字がn個以上|
|{m,n}|直前の文字がm個以上n個以下|
|¥t|タブ|
|¥v|垂直タブ|
|¥r|改行(CR:Carriage Return)|
|¥n|改行(LF:Line Feed)|
|¥f|改ページ|
|¥d|すべての数字(`[0-9]`)|
|¥D|すべての数字以外の文字(`[^0-9]`)|
|¥s|垂直タブ以外のすべての空白文字(`[¥t¥f¥r¥n]`)|
|¥S|すべての非空白文字(`[^¥t¥f¥r¥n]`)|
|¥w|アルファベット、アンダーバー、数字(`[a-zA-Z_0-9]`)|
|¥W|アルファベット、アンダーバー、数字以外の文字(`[^a-zA-Z_0-9]`)|
|¥u|半角英大文字|
|¥U|半角英大文字以外|
|¥l|半角英小文字|
|¥L|半角英小文字以外|
|^|直後の文字が行の先頭にある場合にマッチ|
|$|直前の文字が行の末尾にある場合にマッチ|
|¥<|単語の先頭|
|¥>|単語の末尾|
|¥b|単語の先頭か末尾|
|¥B|単語の先頭か末尾以外|
|¥A|ファイルの先頭|
|¥z|ファイルの末尾|
|¥G|直前の一致文字列の末尾|
|A(?=B)|Aの直後にBがある場合Aにマッチ(肯定的先読み)|
|A(?!B)|Aの直後にBがない場合Aにマッチ(否定的先読み)|
|(?<=B)A|Aの直前にBがある場合Aにマッチ(肯定的後読み)|
|(?<!B)A|Aの直前にBがない場合Aにマッチ(否定的後読み)|

## 正規表現のサンプル一覧

|説明|記述|
|-|-|
|0文字以上の任意の文字列|`.*`|
|1文字以上の任意の文字列|`.+`|
|n桁の半角数字|`¥d{n}`|
|n桁以上の半角数字|`¥d{n,}`|
|m～n桁の半角数字|`¥d{m,n}`|
|桁区切りのカンマ付数字列|`¥b¥d{1,3}(,¥d{3})*¥b`|
|半角英文字|`[¥u¥l]`|
|英単語(半角英文字列)|`¥b[¥u¥l]+¥b`|
|ラテン文字|`¥p{InBasicLatin}`|
|ひらがな|`[ぁ-ん]`(または`¥p{InHiragana}`)|
|カタカナ|`[ァ-ヴ]`(または`¥p{InKatakana}`)|
|半角カタカナ|`[ｦ-ﾟ]`|
|漢字|`¥p{InCJKUnifiedIdeographs}`|
|第2水準の漢字|`[弌-熙]`|
|Windowsの改行コード(CR+LF)|`¥r¥n`|
|全ての改行コード|`¥r¥n\|¥n\|¥r`|
|空白行|`^¥n`|
|行全体|`^.*$`|
|改行を含むすべての文字|`[¥s¥S]*`|
|携帯電話番号|`^0[789]0-¥d{4}-¥d{4}$`|
|Emailアドレス|`^¥w+([-+.]¥w+)*@¥w+([-.]¥w+)*¥.¥w+([-.]¥w+)*$`|
|URL|`^https?://([¥w-]+¥.)+[¥w-]+(/[¥w-./?%&=]*)?$`|

---

## Javaにおける正規表現

### 入力文字列が正規表現にマッチするか判定

```java
// Patternクラス
Pattern.matches("正規表現", "入力文字列");
// Stringクラス
"入力文字列".matches("正規表現");
```

### マッチした文字列を取得

```java
Pattern pattern = Pattern.compile("正規表現");
Matcher matcher = pattern.matcher("入力文字列");
while (matcher.find()) {
  // 開始位置を取得
  int num = matcher.start();
  // 終了位置を取得
  int num = matcher.end();
  // マッチング文字列全体を取得
  String string = matcher.group();
}
```

### サブマッチ文字列

マッチング文字列のうちn番目(先頭から順に1,2,...)の()内に該当する文字列を取得

```java
Pattern pattern = Pattern.compile("...(.+?)...");
Matcher matcher = pattern.matcher("入力文字列");
while (matcher.find()) {
  // n番目の()内にマッチした文字列を取得
  String string = matcher.group(n);
}
```

### マッチフラグ

オプションとして`Pattern.compile`メソッドの第2引数に指定する

```java
Pattern pattern = Pattern.compile("正規表現", Pattern.[マッチフラグ]);
```

"正規表現"の中に`(?フラグ)`の形で埋め込んで指定も可能(途中で無効化する場合は`(?-フラグ)`と指定)
|[マッチフラグ]|埋め込みフラグ|概要|
|-|-|-|
|`CASE_INSENSITIVE`|`?i`|大文字と小文字を区別しない|
|`MULTILINE`|`?m`|複数行モード(「`^`」「`$`」がそれぞれ行末記号(改行)の直後、直前にもマッチ)|
|`DOTALL`|`?s`|DOTALLモード(「`.`」が行末記号を含む任意の文字にマッチ)|
|`UNIX_LINES`|`?d`|「`¥n`」だけを行末記号として扱う|
|`COMMENTS`|`?x`|空白とコメントの有効化|
|`LITERAL`||パターンをリテラル文字として解析(メタ文字やエスケープ文字を無効化)|

### 名前付きキャプチャグループ

グループをタグ`(?<名前>...)`で括ると名前を付けることができる

```java
Pattern pattern = Pattern.compile("...(?<a>.+?)...");
Matcher matcher = pattern.matcher("入力文字列");
while (matcher.find()) {
  // <a>タグのある()内にマッチした部分文字列を取得
  String string = matcher.group("a");
}
```

### グループの後方参照

`¥1`(エスケープ文字を付けて`¥¥1`)にはその前の最初の`(...)`内と同じ文字列が入る

```java
Pattern pattern = Pattern.compile("...(.+?)...¥¥1...");
```

### 名前付きキャプチャグループの後方参照

`¥k<名前>`(エスケープ文字を付けて`¥¥k<名前>`)にはその前の`(?<名前>...)`内と同じ文字列が入る

```java
Pattern pattern = Pattern.compile("...(?<a>.+?)...¥¥k<a>...");
```

### ()をサブマッチの対象外にする

(...)を「`*`」「`+`」の対象をグループ化するのに用いる場合、`(?:...)`とすることでサブマッチの対象から除外できる

```java
Pattern pattern = Pattern.compile("...(?:...)*...");
```

### 置換

```java
String string = "入力文字列".replaceAll("正規表現", "置換後の文字列");
```

### サブマッチ文字列の置換

"置換後の文字列"には`$0`をマッチした文字列全体、`$1`,`$2`...をサブマッチ文字列として含めることができる

```java
String string = "入力文字列".replaceAll("...(.+?)...", "...$1...");
```

### 名前付きキャプチャグループの置換

"置換後の文字列"に`${名前}`を埋め込むと"正規表現"中の`(?<名前>...)`と対応する

```java
String string = "入力文字列".replaceAll("...(?<a>...)...", "...${a}...");
```

### 正規表現で入力文字列を分割する

```java
Pattern pattern = Pattern.compile("正規表現");
String[] string = pattern.split("入力文字列");
```

---

## Pythonにおける正規表現

### reモジュールのインポート

```py
import re
```

### コンパイル

パターンの最初にrを付けると文字列中のバックスラッシュ文字をそのままバックスラッシュとして扱える

```py
pattern = re.compile(r"正規表現")
matchOB = pattern.match("入力文字列")
```

コンパイルせず、検索時にパターンを設定する

```py
matchOB = re.match(r"正規表現", "入力文字列")
```

### 検索方法

|メソッド/属性|目的|
|-|-|
|`match(pattern, string)`|文字列の先頭で正規表現とマッチするか判定する|
|`search(pattern, string)`|文字列を操作して、正規表現がどこにマッチするか調べる|
|`findall(pattern, string)`|正規表現にマッチする部分文字列を全て探しだしリストとして返す|
|`finditer(pattern, string)`|正規表現にマッチする部分文字列を全て探し出しiteratorとして返す|
|`split(pattern, string)`|正規表現にマッチする部分があるたびに分割する|
|`sub(pattern, repl, string)`|正規表現にマッチする部分をreplにある文字に置き換える|

### match関数

文字列の先頭でパターンがマッチするかどうかを判定する

```py
matchOB = re.match(r"正規表現", "入力文字列")
if matchOB:
    print(matchOB.group())
```

### search関数

文字列の中にパターンとマッチする部分があるかどうかを判定する(ただしマッチする箇所が複数ある場合でも最初の1箇所のみを返す)

```py
matchOB = re.search(r"正規表現", "入力文字列"[, "検索開始位置", "検索終了位置"])
if matchOB:
    print(matchOB.group()) #マッチした文字列を返す
    print(matchOB.start()) #マッチの開始位置を返す
    print(matchOB.end())  #マッチの終了位置を返す
    print(matchOB.span())  #マッチの位置(start, end)を含むタプルを返す
```

Matchオブジェクトから情報を取り出す関数
|メソッド|目的|
|-|-|
|`group()`|正規表現にマッチした文字列を返す|
|`group(n)`|n番目(先頭から1,2,...)のサブマッチ文字列(正規表現の中で()でくくられた部分)を返す
|`start()`|マッチの開始位置を返す|
|`end()`|マッチの終了位置を返す|
|`span()`|マッチの位置`(start, end)`を含むタプルを返す|
|`pos`|検索時に指定した開始位置を返す|
|`endpos`|検索時に指定した終了位置を返す|
|`lastindex`|最後にマッチした文字の位置を返す|

### findall関数

文字列の中のパターンとマッチする部分をすべて文字列のリストとして返す

```py
matchlist = re.findall(r"正規表現", "入力文字列")
for result in results:
    print(result)
```

### finditer関数

文字列の中のパターンとマッチする部分をイテレータ(Matchオブジェクト)で返す

```py
matches = re.finditer(r"正規表現", "入力文字列")
for match in matches:
    print match.group()
    print match.start()
    print match.end()
    print match.span()
```

### プロパティ

```py
#コンパイルするパターン
pattern = re.compile(r"正規表現", re.[プロパティ])
matchOB = pattern.match("入力文字列")
#コンパイルしないパターン
matchOB = re.match(r"正規表現", "入力文字列", re.[プロパティ])
```

正規表現の先頭に埋め込みフラグを使って指定も可能

```py
pattern = re.compile(r"(?フラグ)...")
```

|プロパティ|略|埋め込みフラグ|意味|
|-|-|-|-|
|`ASCII`|`A`|`?a`|`\w=[a-zA-Z0-9]`,`\s=[ \t\n\r\f\v]`,`\d=[0-9]`でそれぞれマッチさせる|
|`DOTALL`|`S`|`?s`|単一行モード(「`.`」を改行を含む任意の文字にマッチするようにする)|
|`IGNORECASE`|`I`|`?i`|大文字小文字を区別しない|
|`LOCALE`|`L`|`?L`|ロケールに対応したマッチを行う|
|`MULTILINE`|`M`|`?m`|複数行モード(「`^`」や「`$`」に作用して複数行にマッチングする)|
|`VERBOSE`|`X`|`?x`|正規表現内の空白と改行は無視され、行末に`#`でコメントを加えられる|

### 日本語の扱い方

unicodeにして取り扱う

```py
matchOB = re.match(u"[ぁ-ゞ]",u"あ")
```
